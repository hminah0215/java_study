<< 논리 연산자 >>

&&	논리곱	and	~이고
||	논리합	or	~이거나

&	논리곱	
|	논리합


if(조건1 && 조건2)
		만약 조건1이 거짓이라면 조건2를 아예 판단하지 않아요!
		==>ShortcutOperation

if(조건1 & 조건2)
		무조건 조건1과 조건2를 수행하여 전체가 참인지 판단해요.

=============================================================

this
	==> 생성자나 메소드의 매개변수이름을 의미있는 이름으로 정해주다보면 
		클래스의 멤버변수 이름과 같아지게 되어요. 
		이때, 멤버자신을 구별할 목적으로 this를 사용합니다. 

this()
	==> 생성자가 중복정의되어 있을때에, 나 말고 다른 생성자를 동작시키고자 할 때
		사용하는 키워드입니다.

		이때, this() 키워드는 반드시 생성자의 첫번째 문장에 와야합니다!! 
===============================================================

<< protected >>

상속관계에 있는 자식클래스라 하더라도
부모클래스의 private영역에는 접근할 수 없어요!

만약, 외부의 다른클래스로부터는 보화하되 
상속받는 자식클래스에게는 접근을 허용하고자 한다면
protected 접근 명시자를 사용해요!

===============================================================

<< method overriding >>

상속관계에 있을때 부모로부터 물려받은 메소드가 
자식클래스에게는 그 기능(메소드)이 맞지 않아, 다시 정의하는것을 말합니다. (재정의)

메소드 오버라이딩이 되기위해서는 
메소드 이름뿐 아니라 매개변수의 개수와 자료형까지 일치되게 재정의 되어야 합니다. 

==============================================================

상속받은 자식 클래스는 부모의 모든 속성과 동작을 마치 자신의 것처럼 
사용할 수 있어요. 

만약 부모로 부터 물려받은 기능(메소드)이 자신에게도 알맞다면, 
그대로 사용할 수 있고, 
자신에게 만약 맞지 않다면 재정의하여 사용할 수 있어요. 

==> 자식의 입장에서 선택할 수 있어요. 
      ( 오버라이딩 할지 말지 )

==============================================================

미래에 만들어질 후손클래스들이 공통적으로 가져야 할 속성들과 동작들을 
미리 뽑아서 일반화 시킬 수 있어요. 

	==> 부모클래스를 만들어요.


이때 부모클래스를 만드는 과정에서 미래에 만들어질 후손 클래스들이 
반드시 가져야하는 동작(메소드)이 있는데, 그것이 body를 구체화 할 수 없어요. 
예를들어, 모든 2차원 도형들이 가져야할 속성과 동작을 뽑아서 
Shape이라는 이름의 클래스를 만드는 과정에 
모든 2차원 도형은 면적을 계산하여 calcArea 라는 메소드가 필요해요.
그런데 이게 "원"이될지, "사각형"이 될지, "삼각형"이 될지 
아직 몰라요. 이 모르는 상태에서 calcArea 메소드의 몸통(body)를 구체화 할 수 없어요. 

다음과 같이 메소드의 body를 쓰되 내용을 채우지 않았어요. 
public void calcArea(){
}
위와 같이 두게되면, 후손들에게 선택의 자유를 주게 됩니다. 
(오버라이딩 해도되고, 안해도 되고~)

만약, 선택의 자유를 주지않고 반드시 오버라이딩 하게끔 하려면 
다음과 같이 추상메소드로 만들어야해요!

abstract public void calcArea();
 
이때 바디가 없는 메소드 앞에는 반드시 abstract 키워드를 붙여야해요! 
이러한 메소드를 "추상메소드"라고 합니다.

이와같이 어떤 클래스가 추상메소드를 하나라도 갖고있다면 그 클래스 자신이 
추상 클래스가 되어야 해요!

추상이라는 말은 무엇인가 구체화되지 않은 상태를 말합니다.

===> 추상클래스의 객체는 생성할 수 없어요!!!!!!!!!!!